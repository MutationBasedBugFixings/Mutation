diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-86-b/.defects4j.config /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-86-f/.defects4j.config
--- /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-86-b/.defects4j.config	2025-11-09 16:48:37.279155244 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-86-f/.defects4j.config	2025-11-09 16:48:41.347164802 +0800
@@ -1,3 +1,3 @@
 #File automatically generated by Defects4J
 pid=Math
-vid=86b
+vid=86f
diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-86-b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-86-f/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java
--- /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-86-b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	2025-11-09 16:48:37.280155247 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-86-f/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java	2025-11-09 16:48:41.410164947 +0800
@@ -111,9 +111,6 @@
 
             final double[] lI = lTData[i];
 
-            if (lTData[i][i] < absolutePositivityThreshold) {
-                throw new NotPositiveDefiniteMatrixException();
-            }
             // check off-diagonal elements (and reset them to 0)
             for (int j = i + 1; j < order; ++j) {
                 final double[] lJ = lTData[j];
@@ -134,6 +131,9 @@
             final double[] ltI = lTData[i];
 
             // check diagonal element
+            if (ltI[i] < absolutePositivityThreshold) {
+                throw new NotPositiveDefiniteMatrixException();
+            }
 
             ltI[i] = Math.sqrt(ltI[i]);
             final double inverse = 1.0 / ltI[i];
