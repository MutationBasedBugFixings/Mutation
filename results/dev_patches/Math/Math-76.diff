diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-76-b/.defects4j.config /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-76-f/.defects4j.config
--- /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-76-b/.defects4j.config	2025-11-09 16:47:09.955853555 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-76-f/.defects4j.config	2025-11-09 16:47:14.308873214 +0800
@@ -1,3 +1,3 @@
 #File automatically generated by Defects4J
 pid=Math
-vid=76b
+vid=76f
diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-76-b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-76-f/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
--- /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-76-b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java	2025-11-09 16:47:09.955853555 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff_math/Math-76-f/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java	2025-11-09 16:47:14.375873512 +0800
@@ -159,24 +159,27 @@
             if (m >= n) {
                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                 final RealMatrix e =
-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[m][p];
                 double[] ei1 = eData[0];
-                for (int i = 0; i < p - 1; ++i) {
+                for (int i = 0; i < p; ++i) {
                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
+                    if (i < n - 1) {
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
-                }
+                    } else {
                         for (int j = 0; j < p; ++j) {
-                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
+                            wi[j] = mi * ei0[j] / singularValues[j];
                         }
+                    }
+                }
 
                 for (int i = p; i < m; ++i) {
                     wData[i] = new double[p];
@@ -245,23 +248,26 @@
                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
                 final RealMatrix e =
-                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[n][p];
                 double[] ei1 = eData[0];
-                for (int i = 0; i < p - 1; ++i) {
+                for (int i = 0; i < p; ++i) {
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
+                    if (i < m - 1) {
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
-                }
+                    } else {
                         for (int j = 0; j < p; ++j) {
-                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
+                            wi[j] = mi * ei0[j] / singularValues[j];
                         }
+                    }
+                }
                 for (int i = p; i < n; ++i) {
                     wData[i] = new double[p];
                 }
