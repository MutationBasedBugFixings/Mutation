diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-139-b/.defects4j.config /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-139-f/.defects4j.config
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-139-b/.defects4j.config	2025-11-12 13:02:55.658296449 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-139-f/.defects4j.config	2025-11-12 13:02:59.286296189 +0800
@@ -1,3 +1,3 @@
 #File automatically generated by Defects4J
 pid=Closure
-vid=139b
+vid=139f
diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-139-b/src/com/google/javascript/jscomp/Normalize.java /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-139-f/src/com/google/javascript/jscomp/Normalize.java
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-139-b/src/com/google/javascript/jscomp/Normalize.java	2025-11-12 13:02:55.720296444 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-139-f/src/com/google/javascript/jscomp/Normalize.java	2025-11-12 13:02:59.789296153 +0800
@@ -278,6 +278,9 @@
           }
           break;
 
+        case Token.FUNCTION:
+          normalizeFunctionDeclaration(n);
+          break;
       }
     }
 
@@ -289,6 +292,13 @@
      * to:
      *    var f = function () {};
      */
+    private void normalizeFunctionDeclaration(Node n) {
+      Preconditions.checkState(n.getType() == Token.FUNCTION);
+      if (!NodeUtil.isFunctionAnonymous(n)
+          && !NodeUtil.isHoistedFunctionDeclaration(n)) {
+        rewriteFunctionDeclaration(n);
+      }
+    }
 
     /**
      * Rewrite the function declaration from:
@@ -306,12 +316,23 @@
      *         LP
      *         BLOCK
      */
+    private void rewriteFunctionDeclaration(Node n) {
       // Prepare a spot for the function.
+      Node oldNameNode = n.getFirstChild();
+      Node fnNameNode = oldNameNode.cloneNode();
+      Node var = new Node(Token.VAR, fnNameNode, n.getLineno(), n.getCharno());
+      var.copyInformationFrom(n);
 
       // Prepare the function
+      oldNameNode.setString("");
 
       // Move the function
+      Node parent = n.getParent();
+      parent.replaceChild(n, var);
+      fnNameNode.addChildToFront(n);
 
+      reportCodeChange("Function declaration");
+    }
 
     /**
      * Do normalizations that introduce new siblings or parents.
@@ -518,8 +539,18 @@
         Scope s, String name, Node n, Node parent, Node gramps,
         Node nodeWithLineNumber) {
       Preconditions.checkState(n.getType() == Token.NAME);
-      if (parent.getType() == Token.VAR) {
+      Var v = s.getVar(name);
       // If name is "arguments", Var maybe null.
+      Preconditions.checkState(
+          v == null || v.getParentNode().getType() != Token.CATCH);
+      if (v != null && parent.getType() == Token.FUNCTION) {
+        if (v.getParentNode().getType() == Token.VAR) {
+          s.undeclare(v);
+          s.declare(name, n, n.getJSType(), v.input);
+          replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),
+              v.getParentNode().getParent());
+        }
+      } else if (parent.getType() == Token.VAR) {
         Preconditions.checkState(parent.hasOneChild());
 
         replaceVarWithAssignment(n, parent, gramps);
