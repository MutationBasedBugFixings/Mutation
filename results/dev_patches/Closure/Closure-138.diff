diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-b/.defects4j.config /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-f/.defects4j.config
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-b/.defects4j.config	2025-11-12 13:02:47.441297037 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-f/.defects4j.config	2025-11-12 13:02:51.202296768 +0800
@@ -1,3 +1,3 @@
 #File automatically generated by Defects4J
 pid=Closure
-vid=138b
+vid=138f
diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-b/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-f/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-b/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java	2025-11-12 13:02:47.442297037 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-f/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java	2025-11-12 13:02:51.305296761 +0800
@@ -205,7 +205,6 @@
       Node param = condition.getLastChild();
       if (callee.getType() == GETPROP && param.isQualifiedName()) {
         JSType paramType =  getTypeIfRefinable(param, blindScope);
-        if (paramType != null) {
         Node left = callee.getFirstChild();
         Node right = callee.getLastChild();
         if (left.getType() == NAME && "goog".equals(left.getString()) &&
@@ -215,7 +214,6 @@
           if (restricter != null) {
             return restrictParameter(param, paramType, blindScope, restricter,
                 outcome);
-            }
           }
         }
       }
diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-b/src/com/google/javascript/jscomp/TypeInference.java /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-f/src/com/google/javascript/jscomp/TypeInference.java
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-b/src/com/google/javascript/jscomp/TypeInference.java	2025-11-12 13:02:47.442297037 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-138-f/src/com/google/javascript/jscomp/TypeInference.java	2025-11-12 13:02:51.306296761 +0800
@@ -629,21 +629,29 @@
       return scope;
     } else {
       StaticSlot<JSType> var = scope.getSlot(varName);
-      if (var != null &&
-          !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {
+      if (var != null) {
         // There are two situations where we don't want to use type information
         // from the scope, even if we have it.
 
         // 1) The var is escaped in a weird way, e.g.,
         // function f() { var x = 3; function g() { x = null } (x); }
+        boolean isInferred = var.isTypeInferred();
+        boolean unflowable =
+            isInferred && unflowableVarNames.contains(varName);
 
         // 2) We're reading type information from another scope for an
         // inferred variable.
         // var t = null; function f() { (t); }
+        boolean nonLocalInferredSlot =
+            isInferred &&
+            syntacticScope.getParent() != null &&
+            var == syntacticScope.getParent().getSlot(varName);
 
+        if (!unflowable && !nonLocalInferredSlot) {
           type = var.getType();
           if (type == null) {
             type = getNativeType(UNKNOWN_TYPE);
+          }
         }
       }
     }
