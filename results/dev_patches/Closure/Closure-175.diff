diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-175-b/.defects4j.config /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-175-f/.defects4j.config
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-175-b/.defects4j.config	2025-11-12 13:07:43.380275853 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-175-f/.defects4j.config	2025-11-12 13:07:47.373275567 +0800
@@ -1,3 +1,3 @@
 #File automatically generated by Defects4J
 pid=Closure
-vid=175b
+vid=175f
diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-175-b/src/com/google/javascript/jscomp/FunctionInjector.java /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-175-f/src/com/google/javascript/jscomp/FunctionInjector.java
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-175-b/src/com/google/javascript/jscomp/FunctionInjector.java	2025-11-12 13:07:43.381275853 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-175-f/src/com/google/javascript/jscomp/FunctionInjector.java	2025-11-12 13:07:47.451275561 +0800
@@ -43,6 +43,14 @@
   private final boolean assumeStrictThis;
   private final boolean assumeMinimumCapture;
   private final Supplier<String> safeNameIdSupplier;
+  private final Supplier<String> throwawayNameSupplier =
+      new Supplier<String>() {
+    private int nextId = 0;
+    @Override
+    public String get() {
+      return String.valueOf(nextId++);
+    }
+  };
 
   /**
    * @param allowDecomposition Whether an effort should be made to break down
@@ -205,7 +213,7 @@
     }
 
     if (mode == InliningMode.DIRECT) {
-      return canInlineReferenceDirectly(callNode, fnNode);
+      return canInlineReferenceDirectly(callNode, fnNode, needAliases);
     } else {
       return canInlineReferenceAsStatementBlock(
           t, callNode, fnNode, needAliases);
@@ -687,12 +695,11 @@
    * </pre>
    */
   private CanInlineResult canInlineReferenceDirectly(
-      Node callNode, Node fnNode) {
+      Node callNode, Node fnNode, Set<String> namesToAlias) {
     if (!isDirectCallNodeReplacementPossible(fnNode)) {
       return CanInlineResult.NO;
     }
 
-    Node block = fnNode.getLastChild();
     // CALL NODE: [ NAME, ARG1, ARG2, ... ]
     Node cArg = callNode.getFirstChild().getNext();
 
@@ -712,24 +719,17 @@
       }
     }
 
-    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
-    while (cArg != null || fnParam != null) {
-      if (fnParam != null) {
-        if (cArg != null) {
-          if (NodeUtil.mayEffectMutableState(cArg, compiler)
-              && NodeUtil.getNameReferenceCount(
-                  block, fnParam.getString()) > 1) {
-            return CanInlineResult.NO;
-          }
-        }
-        fnParam = fnParam.getNext();
-      }
+    Map<String, Node> args =
+        FunctionArgumentInjector.getFunctionCallParameterMap(
+            fnNode, callNode, this.throwawayNameSupplier);
+    boolean hasArgs = !args.isEmpty();
+    if (hasArgs) {
       // Limit the inlining
-      if (cArg != null) {
-        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
+      Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias);
+      FunctionArgumentInjector.maybeAddTempsForCallArguments(
+          fnNode, args, allNamesToAlias, compiler.getCodingConvention());
+      if (!allNamesToAlias.isEmpty()) {
         return CanInlineResult.NO;
-        }
-        cArg = cArg.getNext();
       }
     }
 
