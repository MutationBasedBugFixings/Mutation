diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-b/.defects4j.config /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-f/.defects4j.config
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-b/.defects4j.config	2025-11-12 12:59:03.470313073 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-f/.defects4j.config	2025-11-12 12:59:07.347312795 +0800
@@ -1,3 +1,3 @@
 #File automatically generated by Defects4J
 pid=Closure
-vid=110b
+vid=110f
diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-b/src/com/google/javascript/jscomp/ScopedAliases.java /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-f/src/com/google/javascript/jscomp/ScopedAliases.java
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-b/src/com/google/javascript/jscomp/ScopedAliases.java	2025-11-12 12:59:03.471313072 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-f/src/com/google/javascript/jscomp/ScopedAliases.java	2025-11-12 12:59:07.431312789 +0800
@@ -355,6 +355,7 @@
         Node n = v.getNode();
         Node parent = n.getParent();
         boolean isVar = parent.isVar();
+        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
           recordAlias(v);
         } else if (v.isBleedingFunction()) {
@@ -363,12 +364,13 @@
         } else if (parent.getType() == Token.LP) {
           // Parameters of the scope function also get a BAD_PARAMETERS
           // error.
-        } else if (isVar) {
+        } else if (isVar || isFunctionDecl) {
+          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
           Node grandparent = parent.getParent();
-          Node value = n.hasChildren() ?
-              v.getInitialValue().detachFromParent() :
+          Node value = v.getInitialValue() != null ?
+              v.getInitialValue() :
               null;
-          Node varNode = parent;
+          Node varNode = null;
 
           String name = n.getString();
           int nameCount = scopedAliasNames.count(name);
@@ -380,7 +382,9 @@
 
           // First, we need to free up the function expression (EXPR)
           // to be used in another expression.
+          if (isFunctionDecl) {
             // Replace "function NAME() { ... }" with "var NAME;".
+            Node existingName = v.getNameNode();
 
             // We can't keep the local name on the function expression,
             // because IE is buggy and will leak the name into the global
@@ -389,9 +393,19 @@
             //
             // This will only cause problems if this is a hoisted, recursive
             // function, and the programmer is using the hoisting.
+            Node newName = IR.name("").useSourceInfoFrom(existingName);
+            value.replaceChild(existingName, newName);
 
+            varNode = IR.var(existingName).useSourceInfoFrom(existingName);
+            grandparent.replaceChild(parent, varNode);
+          } else {
+            if (value != null) {
               // If this is a VAR, we can just detach the expression and
               // the tree will still be valid.
+              value.detachFromParent();
+            }
+            varNode = parent;
+          }
 
           // Add $jscomp.scope.name = EXPR;
           // Make sure we copy over all the jsdoc and debug info.
@@ -405,7 +419,11 @@
             NodeUtil.setDebugInformation(
                 newDecl.getFirstChild().getFirstChild(), n, name);
 
+            if (isHoisted) {
+              grandparent.addChildToFront(newDecl);
+            } else {
               grandparent.addChildBefore(newDecl, varNode);
+            }
           }
 
           // Rewrite "var name = EXPR;" to "var name = $jscomp.scope.name;"
diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-b/src/com/google/javascript/rhino/Node.java /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-f/src/com/google/javascript/rhino/Node.java
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-b/src/com/google/javascript/rhino/Node.java	2025-11-12 12:59:03.472313073 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-110-f/src/com/google/javascript/rhino/Node.java	2025-11-12 12:59:07.432312789 +0800
@@ -551,6 +551,9 @@
       return null;
     }
     Node n = first;
+    if (n == null) {
+      throw new RuntimeException("node is not a child");
+    }
 
     while (n.next != child) {
       n = n.next;
