diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-76-b/.defects4j.config /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-76-f/.defects4j.config
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-76-b/.defects4j.config	2025-11-12 12:54:39.410331973 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-76-f/.defects4j.config	2025-11-12 12:54:43.225331700 +0800
@@ -1,3 +1,3 @@
 #File automatically generated by Defects4J
 pid=Closure
-vid=76b
+vid=76f
diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-76-b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-76-f/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-76-b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	2025-11-12 12:54:39.411331973 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-76-f/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java	2025-11-12 12:54:43.286331696 +0800
@@ -297,26 +297,40 @@
           // If the currently node is the first child of
           // AND/OR, be conservative only consider the READs
           // of the second operand.
+          if (n.getNext() != null) {
+            state = isVariableReadBeforeKill(
+                n.getNext(), variable);
+            if (state == VariableLiveness.KILL) {
+              state = VariableLiveness.MAYBE_LIVE;
+            }
+          }
+          break;
 
         case Token.HOOK:
           // If current node is the condition, check each following
           // branch, otherwise it is a conditional branch and the
           // other branch can be ignored.
+          if (n.getNext() != null && n.getNext().getNext() != null) {
+            state = checkHookBranchReadBeforeKill(
+                n.getNext(), n.getNext().getNext(), variable);
+          }
+          break;
 
         default:
           for(Node sibling = n.getNext(); sibling != null;
               sibling = sibling.getNext()) {
-            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
             state = isVariableReadBeforeKill(sibling, variable);
+            if (state != VariableLiveness.MAYBE_LIVE) {
+              break;
+            }
+          }
+      }
 
       // If we see a READ or KILL there is no need to continue.
       if (state == VariableLiveness.READ) {
         return true;
       } else if (state == VariableLiveness.KILL) {
         return false;
-            }
-          }
-      }
       }
       n = n.getParent();
     }
@@ -337,6 +351,9 @@
    */
   private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
+    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION
+      return VariableLiveness.MAYBE_LIVE;
+    }
 
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
@@ -359,9 +376,25 @@
       // Conditionals
       case Token.OR:
       case Token.AND:
+        VariableLiveness v1 = isVariableReadBeforeKill(
+          n.getFirstChild(), variable);
+        VariableLiveness v2 = isVariableReadBeforeKill(
+          n.getLastChild(), variable);
         // With a AND/OR the first branch always runs, but the second is
         // may not.
+        if (v1 != VariableLiveness.MAYBE_LIVE) {
+          return v1;
+        } else if (v2 == VariableLiveness.READ) {
+          return VariableLiveness.READ;
+        } else {
+          return VariableLiveness.MAYBE_LIVE;
+        }
       case Token.HOOK:
+        VariableLiveness first = isVariableReadBeforeKill(
+            n.getFirstChild(), variable);
+        if (first != VariableLiveness.MAYBE_LIVE) {
+          return first;
+        }
         return checkHookBranchReadBeforeKill(
             n.getFirstChild().getNext(), n.getLastChild(), variable);
 
@@ -369,13 +402,11 @@
         // Expressions are evaluated left-right, depth first.
         for (Node child = n.getFirstChild();
             child != null; child = child.getNext()) {
-          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
           VariableLiveness state = isVariableReadBeforeKill(child, variable);
           if (state != VariableLiveness.MAYBE_LIVE) {
             return state;
           }
         }
-      }
     }
 
     return VariableLiveness.MAYBE_LIVE;
