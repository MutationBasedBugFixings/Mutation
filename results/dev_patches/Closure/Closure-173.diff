diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-b/.defects4j.config /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-f/.defects4j.config
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-b/.defects4j.config	2025-11-12 13:07:27.386276999 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-f/.defects4j.config	2025-11-12 13:07:31.301276719 +0800
@@ -1,3 +1,3 @@
 #File automatically generated by Defects4J
 pid=Closure
-vid=173b
+vid=173f
diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-b/src/com/google/javascript/jscomp/CodeGenerator.java /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-f/src/com/google/javascript/jscomp/CodeGenerator.java
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-b/src/com/google/javascript/jscomp/CodeGenerator.java	2025-11-12 13:07:27.387276999 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-f/src/com/google/javascript/jscomp/CodeGenerator.java	2025-11-12 13:07:31.388276712 +0800
@@ -127,12 +127,7 @@
       // the IN_FOR_INIT_CLAUSE one.
       Context rhsContext = getContextForNoInOperator(context);
 
-      if (last.getType() == type &&
-          NodeUtil.isAssociative(type)) {
-        addExpr(first, p, context);
-        cc.addOp(opstr, true);
-        addExpr(last, p, rhsContext);
-      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
+      if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
         // Assignments are the only right-associative binary operators
         addExpr(first, p, context);
         cc.addOp(opstr, true);
diff -ruN --exclude .git --exclude .svn --exclude .hg --exclude .idea --exclude .settings --exclude .classpath --exclude .project --exclude target --exclude build --exclude out --exclude bin --exclude '*.class' --exclude '*.jar' --exclude '*.war' --exclude '*.ear' --exclude '*.zip' --exclude '*.tar' --exclude '*.gz' /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-f/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
--- /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	2025-11-12 13:07:27.388276999 +0800
+++ /home1/furqan/my_mutation_experiments/d4j_work_diff/Closure-173-f/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java	2025-11-12 13:07:31.389276712 +0800
@@ -99,12 +99,40 @@
       case Token.ARRAYLIT:
         return tryMinimizeArrayLiteral(node);
 
+      case Token.MUL:
+      case Token.AND:
+      case Token.OR:
+      case Token.BITOR:
+      case Token.BITXOR:
+      case Token.BITAND:
+        return tryRotateAssociativeOperator(node);
 
       default:
         return node; //Nothing changed
     }
   }
 
+  private Node tryRotateAssociativeOperator(Node n) {
+    if (!late) {
+      return n;
+    }
+    Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));
+    Node rhs = n.getLastChild();
+    if (n.getType() == rhs.getType()) {
+      Node parent = n.getParent();
+      Node first = n.getFirstChild().detachFromParent();
+      Node second = rhs.getFirstChild().detachFromParent();
+      Node third = rhs.getLastChild().detachFromParent();
+      Node newLhs = new Node(n.getType(), first, second)
+          .copyInformationFrom(n);
+      Node newRoot = new Node(rhs.getType(), newLhs, third)
+          .copyInformationFrom(rhs);
+      parent.replaceChild(n, newRoot);
+      reportCodeChange();
+      return newRoot;
+    }
+    return n;
+  }
 
   private Node tryFoldSimpleFunctionCall(Node n) {
     Preconditions.checkState(n.isCall());
